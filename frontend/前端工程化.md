

## 模块化

模块化进程：

1.全局function模式：将不同的函数命名在全局作用域中。

​	缺点：容易引起命名冲突，还会污染全局。

2.namespace模式：将不同的函数放到一个全局对象中。

​	缺点：解决了命名冲突，但外部依然可以直接访问，不安全。

3.IIFE（立即执行函数，闭包）：数据是函数私有的，只能通过函数内部暴露给window的接口访问。

​	缺点：当前模块依赖另一个模块无法解决。

4.IIFE增强（引入依赖：给立即执行函数传参）



## 模块化

​	随着web2.0的发展，前端代码量已远远不再是满足一个表单提交的就足够了。模块化，就是为了管理代码，为了解耦和复用代码。

### 发展

1. 全局function模式：将`globalThis`作为全局变量，直接在`globalThis`上存取属性。 缺点：容易引起命名冲突，还会污染全局作用域。
2. namespace模式：在全局作用域上定义一个命名空间，如：jQuery的$。 缺点：解决了命名冲突，但外部依然可以直接随意的操作，不安全。
3. 立即执行函数，闭包：只向外暴露访问函数作用域的方法。 缺点：自此，往后的模块化都是基于闭包。



### AMD

​	推崇依赖前置，在定义模块的时候就要声明其依赖的模块。 	AMD是 Asynchronous Module Definition 的缩写。RequireJS是最佳的实践者，RequireJS主要解决了两个问题：被依赖的模块文件需要更早的加载到浏览器；js加载的时候浏览器会停止页面渲染。 	特点：所有依赖模块的代码会被定义在一个回调函数中，等该模块加载完后，再执行该回调。（代码演示[[module]]）



### CMD

​	推崇就近依赖，只有在用到某个模块的时候再去require。 	CMD是 common module definition  的缩写。CMD规范的浏览器实现是Sea.js。CMD推崇：一个文件就是一个模块；依赖就近。 	特点：用到模块时才去加载模块（加载指的是模块代码的执行，而不是指网络加载模块资源）。（代码演示[[module]]）



### CJS    CommonJS

​	Node 应用由模块组成，采用 CommonJS 模块规范。一个文件就是一个模块，文件内的变量都是私有的。 CommonJS模块化有以下特点： 	所有代码都运行在模块作用域； 	模块可以多次加载，第一次加载时会执行，后续加载都是缓存； 	模块按代码执行顺序加载； 	模块是同步加载的。

CommonJS模块化一些变量： `global`全局变量是个对象，可以用于模块间共享全局变量（不推荐）。 `module`属性指向当前模块。 `exports`属性指向`module.exports`对象，用来存放向外暴露的内容。切勿改变exports的指向。 `require`属性指向`module.require`函数对象，用于加载一个模块文件。 	`require.cache`属性模块加载后的缓存可通过该属性删除。 	`require.resolve`方法可以得到模块所在的路径。 	`require.main`属性可以判断当前模块是否是直接执行，还是被调用执行的。



### UMD

​	UMD是Universal Module Definition的缩写，在ESM标准模块出现之前就有了许多模块化的解决方案。为了能让不同标准的模块在所有运行时中发挥作用，UMD就此诞生了。 	模块最终会导出一个对象、方法、变量。不同模块规范导出的实现是很不相同的，因此需要一种过度机制。



### ESM ECMAScript Module

​	在 ES6 之前的模块化都是，社区制定的一些方案，ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及每个模块输入和输出的变量。 	ESM带来了如下的好处： 	——不再需要`UMD`模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。 	——将来浏览器的新 API 就能用模块格式提供，不再是必须通过全局变量访问。



### 常见npm库

#### patch-package：给别的npm包打补丁