# 设计模式

## 创建型模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

#####	工厂模式

​		定义一个创建实例的接口，不向用户暴露具体的实例化过程。

###### 抽象工厂模式	

​		对工厂类的进一步抽象，用于创建工厂类的工厂

###### 单例模式

​		一个类只有一个实例，暴露一个全局的访问接口，能减少实例化的开销

###### 建造者模式

​		构建一个复杂对象时不去关注具体的细节，胶水代码完成复杂对象的创建。主流程串起来，细节分别实现

###### 	原型模式	

​		通过原型实例来代替类型。如js的原型链

## 结构型模式

###### 	装饰器模式

​		面向切片AOP的思想，不改变原有的类的情况下，插拔式的添加功能

###### 	适配器模式

​		一个引入的类无法使用现有的接口，不去改造接口，也不是重写引入的类，而是为两者的对接实现一个适配器。

###### 	代理模式

​		不去直接操作对象，而是通过代理来间接访问，如js的Proxy

###### 	桥接模式

​		一个类存在多个变化维度，保持这些维度的独立。如：书写css样式时定义多个class，一个tag的class由多个拼凑而成，而不是全部书写至一个class定义中。

###### 	组合模式

​		让对象形成树结构，使其表现出整体与部分的层次结构。如文件系统：根目录下有若干文件和目录，二级目录下还有文件和目录。

###### 	享元模式

​		尽可能减少实例的创建，去使用现有的实例。如网盘资源共享，保存别人网盘的资源不是拷贝一份磁盘数据，只是保存资源地址。

## 行为型模式

###### 	策略模式

​		遇到分支场景，将各个场景分开来。

###### 	模板方法模式

​		定义一个抽象类，将具体的实现延迟至子类，但调用由模板决定。如vue就是一个模板抽象类，组件的state，template需要自己去实现，但组件的render、生命周期的执行、由vue这个抽象类决定。

###### 	观察者模式

​		当对象间存在依赖关系的时候，将对象分为观察者和被观察者，被观察者发生变化的时候，去通知观察者。被观察者需要维护一个list，以便通知观察者。

###### 	订阅发布模式

​		不同于观察者模式，订阅发布模式多了个订阅中心，用来管理订阅者和发布者，订阅者和发布者不需要知道彼此，结构了两者的关系。

###### 	迭代器模式

​		提供一种顺序访问聚合对象的方法，无需暴露对象内部的方法。如：链表的迭代器，帮助我们专注链表内部的数据，而无需关注何时调用next

###### 	责任连模式

​		为多个接收者之前创建引用关系，接受者们都有机会处理请求，当前接受者处理不了则沿着链路传递下去。如：js冒泡、validate

###### 	命令模式

​		将请求封装成各个命令对象，将客户的请求参数化。如：餐厅点餐，不用告知厨师如何做，直接填写菜单就行。

###### 	备忘录模式

​		捕获对象在某个时间切片的状态，以便恢复对象。如：游戏存档、数据库事务处理

###### 	状态模式

​		对象的行为随对象的状态而改变，看起来似乎是类型发生了改变，其实只是状态发生变化。如：数据库链接、在链接前、链接中、链接后会表现出不同行为。

###### 	中介者模式

​		多个对象间存在复杂的关系，通过一个中介将，网状的关系结构转化为星型的结构。

###### 	解释器模式

​		编译一种语法、语法。如：RegExp，sql解释器。

### 设计

##### 设计一个数据结构，插入/删除/查找/random的时间复杂度都是O（1）







