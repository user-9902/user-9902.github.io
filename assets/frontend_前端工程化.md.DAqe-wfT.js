import{_ as a,c as o,o as r,ag as d}from"./chunks/framework.DWIC34_G.js";const s=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/前端工程化.md","filePath":"frontend/前端工程化.md","lastUpdated":null}'),t={name:"frontend/前端工程化.md"};function n(c,e,i,l,p,m){return r(),o("div",null,e[0]||(e[0]=[d('<h2 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h2><p>模块化进程：</p><p>1.全局function模式：将不同的函数命名在全局作用域中。</p><p>​ 缺点：容易引起命名冲突，还会污染全局。</p><p>2.namespace模式：将不同的函数放到一个全局对象中。</p><p>​ 缺点：解决了命名冲突，但外部依然可以直接访问，不安全。</p><p>3.IIFE（立即执行函数，闭包）：数据是函数私有的，只能通过函数内部暴露给window的接口访问。</p><p>​ 缺点：当前模块依赖另一个模块无法解决。</p><p>4.IIFE增强（引入依赖：给立即执行函数传参）</p><h2 id="模块化-1" tabindex="-1">模块化 <a class="header-anchor" href="#模块化-1" aria-label="Permalink to &quot;模块化&quot;">​</a></h2><p>​ 随着web2.0的发展，前端代码量已远远不再是满足一个表单提交的就足够了。模块化，就是为了管理代码，为了解耦和复用代码。</p><h3 id="发展" tabindex="-1">发展 <a class="header-anchor" href="#发展" aria-label="Permalink to &quot;发展&quot;">​</a></h3><ol><li>全局function模式：将<code>globalThis</code>作为全局变量，直接在<code>globalThis</code>上存取属性。 缺点：容易引起命名冲突，还会污染全局作用域。</li><li>namespace模式：在全局作用域上定义一个命名空间，如：jQuery的$。 缺点：解决了命名冲突，但外部依然可以直接随意的操作，不安全。</li><li>立即执行函数，闭包：只向外暴露访问函数作用域的方法。 缺点：自此，往后的模块化都是基于闭包。</li></ol><h3 id="amd" tabindex="-1">AMD <a class="header-anchor" href="#amd" aria-label="Permalink to &quot;AMD&quot;">​</a></h3><p>​ 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。 AMD是 Asynchronous Module Definition 的缩写。RequireJS是最佳的实践者，RequireJS主要解决了两个问题：被依赖的模块文件需要更早的加载到浏览器；js加载的时候浏览器会停止页面渲染。 特点：所有依赖模块的代码会被定义在一个回调函数中，等该模块加载完后，再执行该回调。（代码演示[[module]]）</p><h3 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-label="Permalink to &quot;CMD&quot;">​</a></h3><p>​ 推崇就近依赖，只有在用到某个模块的时候再去require。 CMD是 common module definition 的缩写。CMD规范的浏览器实现是Sea.js。CMD推崇：一个文件就是一个模块；依赖就近。 特点：用到模块时才去加载模块（加载指的是模块代码的执行，而不是指网络加载模块资源）。（代码演示[[module]]）</p><h3 id="cjs-commonjs" tabindex="-1">CJS CommonJS <a class="header-anchor" href="#cjs-commonjs" aria-label="Permalink to &quot;CJS    CommonJS&quot;">​</a></h3><p>​ Node 应用由模块组成，采用 CommonJS 模块规范。一个文件就是一个模块，文件内的变量都是私有的。 CommonJS模块化有以下特点： 所有代码都运行在模块作用域； 模块可以多次加载，第一次加载时会执行，后续加载都是缓存； 模块按代码执行顺序加载； 模块是同步加载的。</p><p>CommonJS模块化一些变量： <code>global</code>全局变量是个对象，可以用于模块间共享全局变量（不推荐）。 <code>module</code>属性指向当前模块。 <code>exports</code>属性指向<code>module.exports</code>对象，用来存放向外暴露的内容。切勿改变exports的指向。 <code>require</code>属性指向<code>module.require</code>函数对象，用于加载一个模块文件。 <code>require.cache</code>属性模块加载后的缓存可通过该属性删除。 <code>require.resolve</code>方法可以得到模块所在的路径。 <code>require.main</code>属性可以判断当前模块是否是直接执行，还是被调用执行的。</p><h3 id="umd" tabindex="-1">UMD <a class="header-anchor" href="#umd" aria-label="Permalink to &quot;UMD&quot;">​</a></h3><p>​ UMD是Universal Module Definition的缩写，在ESM标准模块出现之前就有了许多模块化的解决方案。为了能让不同标准的模块在所有运行时中发挥作用，UMD就此诞生了。 模块最终会导出一个对象、方法、变量。不同模块规范导出的实现是很不相同的，因此需要一种过度机制。</p><h3 id="esm-ecmascript-module" tabindex="-1">ESM ECMAScript Module <a class="header-anchor" href="#esm-ecmascript-module" aria-label="Permalink to &quot;ESM ECMAScript Module&quot;">​</a></h3><p>​ 在 ES6 之前的模块化都是，社区制定的一些方案，ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及每个模块输入和输出的变量。 ESM带来了如下的好处： ——不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。 ——将来浏览器的新 API 就能用模块格式提供，不再是必须通过全局变量访问。</p><h3 id="常见npm库" tabindex="-1">常见npm库 <a class="header-anchor" href="#常见npm库" aria-label="Permalink to &quot;常见npm库&quot;">​</a></h3><h4 id="patch-package-给别的npm包打补丁" tabindex="-1">patch-package：给别的npm包打补丁 <a class="header-anchor" href="#patch-package-给别的npm包打补丁" aria-label="Permalink to &quot;patch-package：给别的npm包打补丁&quot;">​</a></h4>',26)]))}const u=a(t,[["render",n]]);export{s as __pageData,u as default};
