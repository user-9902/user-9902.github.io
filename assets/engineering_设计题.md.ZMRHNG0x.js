import{_ as e,c as i,o as l,ag as t}from"./chunks/framework.CPtCmog4.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/设计题.md","filePath":"engineering/设计题.md","lastUpdated":null}'),r={name:"engineering/设计题.md"};function o(n,a,h,s,d,p){return l(),i("div",null,a[0]||(a[0]=[t('<h4 id="如何设计一个高性能短链系统" tabindex="-1">如何设计一个高性能短链系统？ <a class="header-anchor" href="#如何设计一个高性能短链系统" aria-label="Permalink to &quot;如何设计一个高性能短链系统？&quot;">​</a></h4><p>在一些场景下需要限制url的长度，如短信、宣传物料（海报）中的链接、微博发文字数限制、推荐码。这些场景需要短的连接或隐藏原始链接。</p><p>短链接利用http重定向实现，将短链接与源链接的映射关系存储在数据库中。</p><p>你说要哈希算法生成短链，会存在什么问题（哈希冲突），该怎么解决？（可以用布隆过滤器，但是不好控制，而且仍存在hash冲突）</p><p>有没有更好的方案？（自增序列算法，每次接收一个长链，就分配一个ID，转成62进制再拼到短域后面）</p><p>存在的问题？（自增id方案如果用雪花算法，可能存在机器时钟回拨的问题，导致id重复，说到这里，我终于明白那家伙为什么说要考虑跨机房部署问题）</p><p>该怎么解决？（用Redis做自增id生成器，性能高，但要考虑持久性的问题；或者改造雪花算法，通过改造workId解决时钟回拨的问题）</p><h4 id="防盗链如何设计" tabindex="-1">防盗链如何设计？ <a class="header-anchor" href="#防盗链如何设计" aria-label="Permalink to &quot;防盗链如何设计？&quot;">​</a></h4><p>防止别的网站盗用我们域名下的媒体资源。</p><p>通过http 请求头中的 referr 验证发起请求的域名。</p><h4 id="如何防止用户将网站作为免费网盘" tabindex="-1">如何防止用户将网站作为免费网盘？ <a class="header-anchor" href="#如何防止用户将网站作为免费网盘" aria-label="Permalink to &quot;如何防止用户将网站作为免费网盘？&quot;">​</a></h4><p>当我们的网站有上传、下载功能时。防止用户将我们的网站作为免费网盘。</p><ul><li>上传 <ul><li>身份验证：禁止匿名上传，实名认证等</li><li>流量限制：基于用户每日上传的配额限制，单文件大小上传限制</li><li>文件类型过滤：仅允许业务需要的类型文件上传（jpg，docx，mp4等）</li></ul></li><li>下载 <ul><li>短链接</li><li>动态JWT令牌</li></ul></li></ul><h3 id="登录相关" tabindex="-1">登录相关 <a class="header-anchor" href="#登录相关" aria-label="Permalink to &quot;登录相关&quot;">​</a></h3><h5 id="单点登录" tabindex="-1">单点登录 <a class="header-anchor" href="#单点登录" aria-label="Permalink to &quot;单点登录&quot;">​</a></h5><p>（单点登录：允许用户通过一次身份认证，就可以访问多个物理上独立的应用系统或服务。）</p><p><strong>session</strong>：服务端根据用户的账号等信息生成一个session id，并将用户和session id的映射关系存在服务器上。后续通过用户请求是否携带session id来判断用户的登录状态。由于服务端需要保存session id，这会占用很多服务端资源。</p><p><strong>token</strong>：同session一样，token由于用户的账户等信息生成。但token优化了session对服务端资源的占用。token 生成后只存在于客户端，后续需验证用户携带token的有效性。 token有效性的验证：token由 header-userinfo-signature 三部分组成。服务端验证时，会根据 header userinfo 进行hash运算，运算的结果和signature进行对比。</p><h5 id="登录状态刷新" tabindex="-1">登录状态刷新 <a class="header-anchor" href="#登录状态刷新" aria-label="Permalink to &quot;登录状态刷新&quot;">​</a></h5><h5 id="注销账户" tabindex="-1">注销账户 <a class="header-anchor" href="#注销账户" aria-label="Permalink to &quot;注销账户&quot;">​</a></h5><h5 id="防重登录-登录限制" tabindex="-1">防重登录 &amp; 登录限制 <a class="header-anchor" href="#防重登录-登录限制" aria-label="Permalink to &quot;防重登录 &amp; 登录限制&quot;">​</a></h5><h5 id="扫码登录" tabindex="-1">扫码登录 <a class="header-anchor" href="#扫码登录" aria-label="Permalink to &quot;扫码登录&quot;">​</a></h5><ol><li>二维码生成</li></ol><ul><li>网页端携带设备信息，向服务端请求登录二维码</li><li>服务端返回二维码，同时和网页端保持长连接</li></ul><ol start="2"><li>登录</li></ol><ul><li>移动端扫描网页上的二维码，即移动端向服务端发送确认登录请求。</li><li>服务端收到移动端的确认，生成token，通过长连接返回给网页。</li><li>前端收到token，获取用户信息。</li></ul><p><a href="https://docs.authing.co/v2/concepts/how-qrcode-works.html" target="_blank" rel="noreferrer">扫码登录的原理 | Authing 文档</a></p><h5 id="快捷登录" tabindex="-1">快捷登录 <a class="header-anchor" href="#快捷登录" aria-label="Permalink to &quot;快捷登录&quot;">​</a></h5><p>（快捷登录：网页唤醒微信的快捷登录）</p><p>微信启了一个https本地服务（<a href="https://localhost.weixin.qq.com:13013" target="_blank" rel="noreferrer">https://localhost.weixin.qq.com:13013</a>），提供了一些如 快捷登录 检查是否支持快捷登录等</p><h3 id="优化seo" tabindex="-1">优化SEO <a class="header-anchor" href="#优化seo" aria-label="Permalink to &quot;优化SEO&quot;">​</a></h3><p>（对搜索引擎爬虫的规范）</p><ul><li>爬虫引导： <ul><li>robot.txt ：在服务根目录中配置 robot.txt 来规范搜索引擎的爬虫机器人。</li><li>站点地图：sitmap.xml 站点地图文件配置。</li></ul></li><li>规范书写html： <ul><li>TDK：title description keyword 网页基本信息的配置。</li><li>语义化标签：main aside h1 srction nav 等。</li><li>SSR：对应spa网页，做服务端渲染，保证页面有东西可让爬虫爬取。</li></ul></li></ul><h3 id="发布相关" tabindex="-1">发布相关 <a class="header-anchor" href="#发布相关" aria-label="Permalink to &quot;发布相关&quot;">​</a></h3><h5 id="蓝绿部署" tabindex="-1">蓝绿部署 <a class="header-anchor" href="#蓝绿部署" aria-label="Permalink to &quot;蓝绿部署&quot;">​</a></h5><p>准备两套物理集群，先在空闲集群上完成新版本的部署，再将全部流量切到新版本集群上，以完成版本更新。</p><h5 id="红黑部署" tabindex="-1">红黑部署 <a class="header-anchor" href="#红黑部署" aria-label="Permalink to &quot;红黑部署&quot;">​</a></h5><p>区别于蓝绿部署。红黑部署利用云计算的虚拟化，减少了网关切流的过程，弹性伸缩的优势，同时保证了算力。</p><h5 id="灰度发布-金丝雀发布" tabindex="-1">灰度发布 / 金丝雀发布 <a class="header-anchor" href="#灰度发布-金丝雀发布" aria-label="Permalink to &quot;灰度发布 / 金丝雀发布&quot;">​</a></h5><p>灰度发布是增量部署，逐步部署新功能或新方法的发布方式，将新功能推送给<strong>部分用户</strong>，通过监控和反馈判断是否进行全面推广。</p><p>实践中需要注意的点：</p><ul><li>数据库对新旧版本的兼容性。涉及到删除字段、更新字段的操作需要格外注意。</li><li>不能直接用 nginx weight 来控制版本，这会导致同一用户可能在新旧版本之间反复横跳。可以nginx + lua 脚本对用户的特征值如ip取模。</li><li>新版本检测要做到位，可以让新版本集群保持相对高压，再酌情扩容。</li></ul><h5 id="回滚" tabindex="-1">回滚 <a class="header-anchor" href="#回滚" aria-label="Permalink to &quot;回滚&quot;">​</a></h5><p>在灰度发布的基础上，很好实现，将新版本内容的流量切走即可。</p><p>回滚的关键是回滚后的数据修复。有以下注意点：数据库表结构只增不改+垂直分表；数据库建表时冗余字段+冗余字段描述表；若结构扩容，存储JSON类型数据。</p><h5 id="ci-cd" tabindex="-1">CI/CD <a class="header-anchor" href="#ci-cd" aria-label="Permalink to &quot;CI/CD&quot;">​</a></h5>',46)]))}const q=e(r,[["render",o]]);export{c as __pageData,q as default};
