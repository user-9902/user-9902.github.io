import{_ as a,c as r,o,ag as c}from"./chunks/framework.DWIC34_G.js";const s=JSON.parse('{"title":"Docker","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/docker.md","filePath":"engineering/docker.md","lastUpdated":null}'),i={name:"engineering/docker.md"};function t(d,e,l,n,p,k){return o(),r("div",null,e[0]||(e[0]=[c('<h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><h2 id="什么是docker" tabindex="-1">什么是Docker <a class="header-anchor" href="#什么是docker" aria-label="Permalink to &quot;什么是Docker&quot;">​</a></h2><p>一个web服务由诸多应用组成（redis、jdk、mysql），当我们开发、维护该web服务时，需要维护组成该服务的诸多应用。这种复杂性，对开发、测试、运维的标准开发流程过程带来了挑战：如何保证服务在不同环境中的一致性、如何更高效的利用操作系统的资源等。</p><h2 id="容器化的方案" tabindex="-1">容器化的方案 <a class="header-anchor" href="#容器化的方案" aria-label="Permalink to &quot;容器化的方案&quot;">​</a></h2><h3 id="虚拟机" tabindex="-1">虚拟机 <a class="header-anchor" href="#虚拟机" aria-label="Permalink to &quot;虚拟机&quot;">​</a></h3><p>为了能够将我们搭建好的环境，完整的从开发环境移植到测试环境、生产环境，我们需要一种容器技术。由于所有的应用都是运行在操作系统上的，自然我们就会想到虚拟机技术，通过虚拟机的镜像克隆来完成移植。</p><p>但虚拟机存在诸多不足：硬件资源浪费、启动慢等。</p><h3 id="docker的容器化" tabindex="-1">docker的容器化 <a class="header-anchor" href="#docker的容器化" aria-label="Permalink to &quot;docker的容器化&quot;">​</a></h3><p>docker的诞生解决了虚拟机过于笨重的问题，docker将程序以及程序所需要的依赖打包到docker container，同时屏蔽了操作系统的差异。货物（程序）在集装箱（容器）里，无需关注其在哪艘船（操作系统）里。</p><h2 id="docker是如何工作的" tabindex="-1">Docker是如何工作的 <a class="header-anchor" href="#docker是如何工作的" aria-label="Permalink to &quot;Docker是如何工作的&quot;">​</a></h2><ul><li><p>镜像（Image）：Docker 镜像是容器运行的模板。</p></li><li><p>容器（Container）：容器是镜像运行实例。</p></li><li><p>仓库（Repository）：存放镜像的仓库。</p></li><li><p>dockerfile：我们编写的配置文件 ↓ docker build</p></li><li><p>image：打包后的镜像文件 ↓ docker run</p></li><li><p>container：运行的镜像实例</p></li></ul><h3 id="docker的底层实现" tabindex="-1">docker的底层实现 <a class="header-anchor" href="#docker的底层实现" aria-label="Permalink to &quot;docker的底层实现&quot;">​</a></h3><p>NameSpace：Linux中的PID、IPC、网络等资源是全局的，而NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰，这就使得每个NameSpace看上去就像一个独立的操作系统一样。</p><p>Control groups：有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</p>',14)]))}const u=a(i,[["render",t]]);export{s as __pageData,u as default};
