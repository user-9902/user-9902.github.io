import{_ as t,c as a,o as i,ag as r}from"./chunks/framework.DWIC34_G.js";const c=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/vue.md","filePath":"frontend/vue.md","lastUpdated":null}'),s={name:"frontend/vue.md"};function d(o,e,n,h,p,l){return i(),a("div",null,e[0]||(e[0]=[r(`<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h3 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h3><p><a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#reactivity-in-depth" target="_blank" rel="noreferrer">深入响应式系统 | Vue.js (vuejs.org)</a></p><p>响应式即当数据发生变换的时候，依赖变化数据的视图随之响应，跟随变化，当然响应式也不局限于视图于数据之间的关系。</p><p>vue2借助Object.defineProperty实现的响应式，通过该Object.defineProperty可以自定义一个对象的一个属性的getter和setter。</p><p>订阅发布模式：</p><p>若一个视图内容依赖响应式数据，便会触发数据的getter，getter中处理视图与该数据的依赖关系，使得视图订阅数据的变化。</p><p>当响应式数据发送改变的时候，便会触发数据的setter，这是便可以去通知订阅该数据变化的视图，使得视图能随着数据的变化而变化。</p><h3 id="vue模板编译原理" tabindex="-1">vue模板编译原理 <a class="header-anchor" href="#vue模板编译原理" aria-label="Permalink to &quot;vue模板编译原理&quot;">​</a></h3><p>模板编译即将template模板编译成render函数的过程，这个过程在Vue内部通过解析器、转换器和生成器三个组件来完成。解析器负责将模板解析为AST，转换器负责将AST转换为JS抽象语法树，生成器则负责将JS抽象语法树生成render函数。</p><p>ast抽象语法树生成：这个过程通过词法分析和语法分析，将模板字符串拆分成一系列的词法单元（tokens），然后将这些词法单元组合成一颗AST，在解析过程中，Vue会识别模板中的原生HTML和非原生HTML元素，如绑定的属性、事件、指令等，并将它们作为AST的一部分。</p><p>ast树优化：Vue会对其进行一系列优化操作，以提高渲染性能。这些优化包括静态节点提升、表达式节点优化等。静态节点在后续渲染的过程中会跳过重新渲染，以提高diff速度。</p><p>render函数的生成：经过优化的AST会被转换成渲染函数。渲染函数是一个JavaScript函数，它接受一个参数h（通常是一个名为createElement的函数），用来创建虚拟DOM。</p><p>render函数的执行：render函数接受一个h函数，render函数执行会生成一个虚拟dom，然后vue就可以将虚拟dom转化为真实dom了。</p><h3 id="什么是虚拟dom" tabindex="-1">什么是虚拟dom <a class="header-anchor" href="#什么是虚拟dom" aria-label="Permalink to &quot;什么是虚拟dom&quot;">​</a></h3><p>虚拟dom是对真实dom的抽象表示，包含的真实dom的tag类型、attribute等。同时虚拟dom还可以包含一些动态的数据，即组件的状态数据等。</p><p>虚拟dom有如下好处：</p><p>​ 带来了跨平台能力：vnode可以是对浏览器dom的描述，也可以是对微信小程序wxml结构的描述。</p><p>​ 可以减少dom来提高性能：将对dom节点的操作统一执行，</p><p>​ 使得diff算法更轻量：vnode节点对象比真实dom对象数据量少，便于diff算法的执行，优化了更新的性能。</p><h3 id="nexttick的理解" tabindex="-1">nextTick的理解 <a class="header-anchor" href="#nexttick的理解" aria-label="Permalink to &quot;nextTick的理解&quot;">​</a></h3><p>用法：nextTick可以传入一个回调函数，使该函数在dom节点发生更新后执行。</p><h3 id="v-model的原理" tabindex="-1">v-model的原理 <a class="header-anchor" href="#v-model的原理" aria-label="Permalink to &quot;v-model的原理&quot;">​</a></h3><p>v-model用以实现视图和input文本框、父子组件间的数据同步，是一个v-bind:value和v-on:input的语法糖。</p><p>应用在文本框时，v-model给文本框传递一个props，改变其value的值，将model层的数据展示在view视图层，当文本框的内容发送变化的时候，会触发input事件，v-model监听了input事件，使得view层的变化也能响应在model层上。</p><p>应用在父子组件间也是这个道理。</p><h3 id="componsition-api" tabindex="-1">componsition API <a class="header-anchor" href="#componsition-api" aria-label="Permalink to &quot;componsition API&quot;">​</a></h3><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个响应式变量</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({a:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回一个引用类型的响应式代理，推荐使用ref创建保证统一性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 本质上是lazy watcher 当依赖发生变化的时候，将数据标记为dirty，下次get的时候，重新计算。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="内置组件的理解" tabindex="-1">内置组件的理解 <a class="header-anchor" href="#内置组件的理解" aria-label="Permalink to &quot;内置组件的理解&quot;">​</a></h3><h6 id="transition" tabindex="-1">Transition <a class="header-anchor" href="#transition" aria-label="Permalink to &quot;Transition&quot;">​</a></h6><p>用以为组件添加加入dom和离开dom的特效动画。</p><p>v-enter-from v-enter-active v-enter-to：用以设定元素添加至dom的起始、生效、结束样式和动画。</p><p>v-leave-from v-leave-active v-leave-to：用以设定元素从dom中删除的起始、生效、结束样式和动画。</p><h6 id="transitiongroup" tabindex="-1">TransitionGroup <a class="header-anchor" href="#transitiongroup" aria-label="Permalink to &quot;TransitionGroup&quot;">​</a></h6><p>和transition基本相同，transiton的子组件只能是一个，TransitionGroup的则是用以一组数据的动画，子组件的attribute key必须是唯一的。</p><h6 id="teleport" tabindex="-1">Teleport <a class="header-anchor" href="#teleport" aria-label="Permalink to &quot;Teleport&quot;">​</a></h6><p>​ 组件在使用时，常常受限于其层级关系，如需要一个组件渲染至app根节点之外的地方就需要teleport组件了。通过to确定传输的位置。</p><h6 id="fragment" tabindex="-1">Fragment <a class="header-anchor" href="#fragment" aria-label="Permalink to &quot;Fragment&quot;">​</a></h6><p>​ vue2中单页面组件的根节点只能是一个节点，vue3中支持多根节点，多个根节点会被置于一个fragment节点中。</p><h6 id="suspense" tabindex="-1">Suspense <a class="header-anchor" href="#suspense" aria-label="Permalink to &quot;Suspense&quot;">​</a></h6><p>​ 常见于异步组件加载的场景，加载组件不满足状态的时候，会处于fallback状态，直至满足加载条件</p><h6 id="keepalive" tabindex="-1">KeepAlive <a class="header-anchor" href="#keepalive" aria-label="Permalink to &quot;KeepAlive&quot;">​</a></h6><p>​ 多个组件切换状态的时候缓存组件实例。</p><h3 id="slot的概念和使用" tabindex="-1">Slot的概念和使用 <a class="header-anchor" href="#slot的概念和使用" aria-label="Permalink to &quot;Slot的概念和使用&quot;">​</a></h3><p>​ 组件间传递的一般是状态数据，而slot传递的是template，组件可以在template结构中定义一个slot插槽，交由其父组件决定slot中填入什么内容</p><h3 id="vue自定义指令" tabindex="-1">vue自定义指令 <a class="header-anchor" href="#vue自定义指令" aria-label="Permalink to &quot;vue自定义指令&quot;">​</a></h3><p>​ vue的内置指令有v-for v-if等，vue给用户提供了自定义指令能力，以便复用一些常见的dom操作，用户可以借助自定义指令补足内置指令无法满足的需求。</p><p>​ 自定义指令分为全局自定义指令和局部自定义指令。全局自定义指令通过app .directive注册，组件局部自定义指令通过组件options中的directive属性进行注册。</p><p>​ 自动指令可以决定元素在相应的组件生命周期中表现出哪些行为。下面是一个自动聚焦的自定义指令的实现：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;focus&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="vue-router中hash路由和history路由的原理" tabindex="-1">vue-router中hash路由和history路由的原理 <a class="header-anchor" href="#vue-router中hash路由和history路由的原理" aria-label="Permalink to &quot;vue-router中hash路由和history路由的原理&quot;">​</a></h3><p>spa应用只有单个页面，为了使得spa拥有传统mpa应用页面前进后退的功能，vue-router提供了两种模式，hash和history。</p><p>hash指的是url链接#后面的内容。hash值原本用以页面的锚点，当hash变化时，页面跳转至指定位置。通过onhashchange可以监视hash的变化；通过location.hash能够修改hash</p><p>history模式借助的是H5 API history，可以管理页面路径。通过history.pushState()或者history.replaceState()</p><h3 id="vue-router相关勾子和与其执行时机" tabindex="-1">vue-router相关勾子和与其执行时机 <a class="header-anchor" href="#vue-router相关勾子和与其执行时机" aria-label="Permalink to &quot;vue-router相关勾子和与其执行时机&quot;">​</a></h3><p>全局：beforeEach beforeResolve afterEach <br>路由配置独享：beforeEnter<br>组件内：beforeRouteLeave beforeRouteUpdate beforeRouteEnter</p><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="组件间通讯" tabindex="-1">组件间通讯 <a class="header-anchor" href="#组件间通讯" aria-label="Permalink to &quot;组件间通讯&quot;">​</a></h3><p>父子： props / $emit；$parent / $children</p><p>祖先后代： provider / inject</p><p>全局： vuex；eventbus；sessionStorage；自定义订阅发布（CustomEvent addEventListener dispatchEvent）</p><h3 id="组件和插件的区别" tabindex="-1">组件和插件的区别 <a class="header-anchor" href="#组件和插件的区别" aria-label="Permalink to &quot;组件和插件的区别&quot;">​</a></h3><p>组件是视图、演示、数据状态的组合，每个.vue文件即一个组件，内部集合了业务逻辑，如输入框，日历选择器，都可以单独封装出一个组件，职责单一，降低了系统的耦合度。组件能够重复使用，提高了系统的一致性体验和整体性。</p><p>插件能对Vue进行修改或补充，可以添加全局的方法或属性如vue-custom-element，可以添加全局的资源如vue-touch，可以混入一些组件如vue-router，可以调整vue的原型等。</p><h3 id="computed和watch的区别" tabindex="-1">computed和watch的区别 <a class="header-anchor" href="#computed和watch的区别" aria-label="Permalink to &quot;computed和watch的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>比较维度</th><th>computed</th><th>watch</th></tr></thead><tbody><tr><td>返回值</td><td>必须要有返回值</td><td>无返回值</td></tr><tr><td>缓存机制</td><td>有缓存</td><td>无缓存</td></tr><tr><td>使用场景</td><td>返回值被当作数据使用，当依赖的数据发生改变时会重新计算值</td><td>监听数据的变化，</td></tr><tr><td>初始化</td><td>不会自动执行</td><td>可以设置immediate值为true，来立即执行</td></tr><tr><td>深度监听</td><td>不支持深度监听</td><td>支持深度监听</td></tr></tbody></table><h3 id="vue3相较于vue2改进了些什么" tabindex="-1">vue3相较于vue2改进了些什么？ <a class="header-anchor" href="#vue3相较于vue2改进了些什么" aria-label="Permalink to &quot;vue3相较于vue2改进了些什么？&quot;">​</a></h3><p>重写了响应式系统，借助Proxy能一次处理一个对象，更高效。</p><p>API风格发生了改变，setup语法糖 + Composition API 将同一数据相关的逻辑聚集到一起，优于Options API所带来的割裂感。</p><p>增加了对map和set数据类型的支持。</p><p>使用TypeScript的重写，使得开发更加高效。</p><p>新的内置组件 Teleport传送真实dom至指定位置；Suspense用以平滑过渡异步组件；Fragment用以解决组件多个根节点的问题。</p><p>基于ESM的模块化使得Tree-shaking得到支持，打包后的代码体积更小。</p><p>新生命周期setup在beforCreated之前，destroy改名unmount</p><p>v-for和v-if的优先级问题被解决</p><p>diff算法的优化，diff算法中为虚拟dom添加了静态标签，优化了静态内容在diff中的速度</p><h3 id="vue和react的异同" tabindex="-1">vue和react的异同 <a class="header-anchor" href="#vue和react的异同" aria-label="Permalink to &quot;vue和react的异同&quot;">​</a></h3><table tabindex="0"><thead><tr><th>同</th><th>异</th></tr></thead><tbody><tr><td>都有组件化思想</td><td>数据流不同，react推崇单向数据流，vue推崇双向绑定</td></tr><tr><td>都支持服务器端渲染</td><td>diff算法不同，react保存需要更新的dom节点，批量更新；vue使用双指针，变对比边更新。</td></tr><tr><td>都有虚拟dom</td><td>组件通讯方式不同，react通过回调函数props的形式，vue可以使用回调函数props或emit事件</td></tr><tr><td>都有自己的构建工具</td><td></td></tr><tr><td>都有对应的原生解决方案</td><td></td></tr></tbody></table><h3 id="vue首屏如何优化" tabindex="-1">vue首屏如何优化 <a class="header-anchor" href="#vue首屏如何优化" aria-label="Permalink to &quot;vue首屏如何优化&quot;">​</a></h3><p>vue页面的内容都存在js文件中，首屏html结构是空的，因此首屏是白屏，可以用如下方法优化：</p><p>减少打包体积，webpack配置多入口。</p><p>路由懒加载</p><p>CDN加速</p><p>SSR服务端渲染首屏</p><p>spa改为mpa配置</p><h3 id="杂项" tabindex="-1">杂项 <a class="header-anchor" href="#杂项" aria-label="Permalink to &quot;杂项&quot;">​</a></h3><table tabindex="0"><thead><tr><th>问</th><th>答</th></tr></thead><tbody><tr><td>常见vue内部指令</td><td>v-if v-once v-show v-bind v-on v-text v-html v-for v-cloak v-memo</td></tr><tr><td>vue修饰符</td><td>用以v-bind或v-on的修饰，.lazy .trim .number .stop .prevent .caputure .self .once .sync</td></tr><tr><td>v-if和v-show的异同</td><td>都能控制元素的显影，v-if是通过添加或删除虚拟dom进而控制真实dom开销大，v-show是基于display：none实现的</td></tr><tr><td>同一标签中v-for和v-if的冲突</td><td>vue2中在vnode的生成时v-for是优先于v-if执行的，会带来不必要的开销。但vue3中优化了这一点1</td></tr><tr><td>vue.set的作用</td><td>vue2中受限于api，无法检测到对象属性的添加和删除、数组元素的修改，通过this.$set或来为对象或数组添加相应式数据，相对的vue.delete用来删除属性</td></tr><tr><td>父子组件生命周期的顺序</td><td>mounted updated distroyed 是子组件先，其余都父组件先</td></tr><tr><td>v-on可以监听多个方法么</td><td>可以，逗号隔开</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1>`,88)]))}const v=t(s,[["render",d]]);export{c as __pageData,v as default};
