import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.DWIC34_G.js";const c=JSON.parse('{"title":"React","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/react.md","filePath":"frontend/react.md","lastUpdated":null}'),e={name:"frontend/react.md"};function t(p,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h1><p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案。react特点如下：</p><ul><li>JSX 语法：jsx用于描述虚拟dom，直接使用React.createElement来描述虚拟dom不够直观。jsx（js + xml）借助 babel（or swc）转义为纯js。</li><li>单向数据绑定：</li><li>虚拟 DOM：虚拟dom用于描述真实dom，两者呈一一对应的关系。虚拟dom的存储开销小、存储的信息更简单，我们通过操作虚拟dom，来间接操作真实dom。虚拟dom还使得react具备了跨平台的能力。</li><li>声明式编程：</li><li>Component：将ui和js逻辑抽象为一个个组件，再通过组件拼凑出一个完整的应用。提高了代码复用率和开发效率。</li></ul><h3 id="什么是纯函数-副作用函数" tabindex="-1">什么是纯函数？副作用函数？ <a class="header-anchor" href="#什么是纯函数-副作用函数" aria-label="Permalink to &quot;什么是纯函数？副作用函数？&quot;">​</a></h3><p>纯函数（Pure function），是函数式编程规范中非常重要的概念，有以下特点：</p><ol><li><strong>确定性/幂等性（Determinism）</strong>：相同的输入参数，纯函数<strong>总产生相同的输出结果</strong>，无论函数被调用多少次，也不管何时何地调用。</li><li><strong>无副作用（No Side Effects）</strong>：纯函数的执行<strong>不访问或修改外部状态</strong>、不引发异常、不进行io操作（如打印到控制台、读写文件、网络请求等），其效果局限于函数内部，对外界环境没有可观察的变化。</li></ol><p>副作用函数（Impure Function）指那些不满足上述纯函数特性的函数：</p><ol><li><strong>非确定性</strong>：同样的输入在不同时间或环境下可能产生不同的输出。</li><li><strong>有副作用</strong>：函数执行时会影响外部状态，比如修改全局变量、改变输入参数、输出信息到控制台、读写文件、发起网络请求等。</li></ol><h3 id="mvvm是什么" tabindex="-1">MVVM是什么 <a class="header-anchor" href="#mvvm是什么" aria-label="Permalink to &quot;MVVM是什么&quot;">​</a></h3><p>model-view-viewmodel的缩写。</p><p>model即模型（或数据模型），存储着的状态数据；</p><p>view即视图（或数据表现），即向用户展示的结构、布局、外观；</p><p>viewmodel即视图模型，视图层和模型层之间借助viewmodel进行沟通，viewmodel监听model层的数据变化，将变化展示在view层，同时viewmodel监听view层用户的交互事件、视图的变化以通知model层。vue中的mvvm是双向绑定的，视图层的变化数据将同步到model，model数据的变化也会立即响应到view上。</p><h5 id="mvvm和mvc的区别" tabindex="-1">mvvm和mvc的区别 <a class="header-anchor" href="#mvvm和mvc的区别" aria-label="Permalink to &quot;mvvm和mvc的区别&quot;">​</a></h5><p>c即controller，controller需要主动的去维护view和model两者的关系，夹杂着大量的代码，使得系统复杂度高；大量的DOM操作使用户体验差。viewmodel是controller的演进，能自动维护view和model的关系，降低系统复杂度，抽离出业务逻辑，使得开发者更加的专注于业务逻辑开发。</p><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><p>为提高代码的复用率，我们将重复使用的 js数据逻辑和视图逻辑 整合到一起作为组件。</p><h5 id="函数组件和类组件" tabindex="-1">函数组件和类组件 <a class="header-anchor" href="#函数组件和类组件" aria-label="Permalink to &quot;函数组件和类组件&quot;">​</a></h5><p>类组件：类组件通过继承 React.Component 来编写，通过</p><table tabindex="0"><thead><tr><th></th><th>类组件</th><th>函数组件</th></tr></thead><tbody><tr><td>编写方式</td><td>React.Component 来编写，必须实现render函数</td><td>返回类型为 jsx 的函数</td></tr><tr><td>生命周期</td><td>见下生命周期</td><td>useEffect 替代生命周期的作用</td></tr><tr><td>状态 state</td><td>this.state</td><td>useState</td></tr><tr><td>props</td><td>this.props</td><td>函数入参</td></tr></tbody></table><p>hooks api推出之前，函数组件是无状态的，只能用于编写简单的，无状态的组件。随着 hooks api的流行，函数组件中也能实现状态管理、生命周期，使得函数组件开始流行。</p><h5 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h5><p>组件创建阶段</p><ul><li>constructor：类组件实例创建的时候执行</li><li>getDerivedStateFromProps：是一个静态的方法，不能访问到组件实例，该函数需要返回一个对象作为新 state 或返回 null 表示无需更新 state</li><li>render：类组件必须有的方法，该方法返回虚拟dom</li><li>componentDidMount：组件完成创建</li></ul><p>组件更新阶段</p><ul><li>getDerivedStateFromProps</li><li>shouldComponentUpdate：该方法需返回一个boolean值，用于控制是否继续后续的更新组件流程。</li><li>render</li><li>getSnapshotBeforeUpdate：render执行后，真实dom更新前执行</li><li>componentDidUpdate：组件完成更新</li></ul><p>组件卸载阶段</p><ul><li>componentWillUnmount：清除一些监听事件，取消订阅等清理工作。</li></ul><h5 id="组件间通讯" tabindex="-1">组件间通讯 <a class="header-anchor" href="#组件间通讯" aria-label="Permalink to &quot;组件间通讯&quot;">​</a></h5><ul><li>父组件 → 子组件：props</li><li>子组件 → 父组件：callback props</li><li>祖先 → 后代：provider context</li><li>兄弟间/全局：redux 订阅发布（mitt等三方库）</li></ul><h5 id="受控组件-非受控组件" tabindex="-1">受控组件/非受控组件 <a class="header-anchor" href="#受控组件-非受控组件" aria-label="Permalink to &quot;受控组件/非受控组件&quot;">​</a></h5><p>表单元素通过 value onChange 来获取值的变化，即为受控组件。</p><p>非受控组件则需要通过ref来手动获取表单元素的值。</p><h3 id="hooks" tabindex="-1">Hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;Hooks&quot;">​</a></h3><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useState </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单数据类型的状态管理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialState)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// userReducer </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂数据类型的状态管理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Taylor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, initFn)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useSyncExternalStore</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于从外部存储（例如状态管理库、浏览器 API 等）获取状态并在组件中同步显示</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// subscribe 用于订阅状态库，还需返回一个卸载订阅的方法；getSnapshot 用于触发订阅；getServerSnapshot用于SSR中触发订阅</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSyncExternalStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(subscribe, getSnapshot, getServerSnapshot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useTransition</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于UI的过渡，特别是需要长时间运行的状态更新时。react会优先处理更高优先级的更新。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const [isPending, startTransition] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useDeferredValue</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useEffect</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用的勾子，在真实dom更新后执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以模拟componentDidMount componentDidUpdate componentWillUnmount</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(setup, dependencies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useLayoutEffect</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用法同useEffect，但执行时机是在render执行完毕后，真实dom渲染之前</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以模拟 componentWillMount getSnapshotBeforeUpdate componentWillUnmount</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useLayoutEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(setup, dependencies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useRef</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于获取dom实例，在此render不会重新赋值，不会重新赋值的特点，可以用在定时器等功能的实现上</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const divRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{divRef}&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// userImperativeHandle</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子组件自定义向父组件暴露的方法和属性, 父组件通过useRef访问子组件暴露的数据</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// react 18 需要结合React.forwardRef使用，react 19中简化了。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Father</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> divRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{divRef}&gt;&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}){ </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	userImperativeHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ref, ()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}, []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第三个参数可选，同useEffect，数据发送变化了同步给父组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useContext</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于祖孙间的通讯</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const ThemeContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThemeContext.Provider</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{theme:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;light&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThemeContext.Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// react 19 不需要.Provider</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> theme</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ThemeContext)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;&gt;...&lt;/&gt;       </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useMemo</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于缓存计算的结果,用于性能优化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const cachedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [count])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Component) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 补充</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useCallback</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于缓存函数，用于性能优化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const memoizedCallback </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [a, b]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数组件内部的一些函数随着重新渲染的执行，会被反复创建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useDebugValue</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配合devtools使用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useDebugValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`format:\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">val</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br></div></div><h3 id="fiber" tabindex="-1">fiber <a class="header-anchor" href="#fiber" aria-label="Permalink to &quot;fiber&quot;">​</a></h3><h5 id="why-fiber" tabindex="-1">Why fiber <a class="header-anchor" href="#why-fiber" aria-label="Permalink to &quot;Why fiber&quot;">​</a></h5><p>浏览器中，js是单线程的，同时js线程与render线程是互斥的。当有大量的js任务在执行时，render线程会被阻断，导致页面的卡顿，为此我们需要更细颗粒度的线程控制来平衡js的执行和页面的渲染，这也就是react使用fiber（纤程）的原因了。</p><h5 id="任务切片" tabindex="-1">任务切片 <a class="header-anchor" href="#任务切片" aria-label="Permalink to &quot;任务切片&quot;">​</a></h5><p>react将一个大的渲染（虚拟dom运算）任务进行拆分，分为许多切片，每一帧中执行一个任务切片，减轻js线程对render线程的影响，保证页面绘制的流畅。</p><h5 id="fiber-tree" tabindex="-1">fiber tree <a class="header-anchor" href="#fiber-tree" aria-label="Permalink to &quot;fiber tree&quot;">​</a></h5><p>虚拟dom是一个树结构，基于上述任务切片的需求，我们需要从一个叶子节点恢复出一个完整的树（渲染子组件时被打断，下一个时间切片中在继续后续的渲染）。传统的树的结构是无法满足的，所有使用fiber tree。fiber tree 在传统树结构的基础上，所有子节点保存了对父节点的索引，所有节点保存对兄弟节点的索引。</p><h5 id="任务调度" tabindex="-1">任务调度 <a class="header-anchor" href="#任务调度" aria-label="Permalink to &quot;任务调度&quot;">​</a></h5><p><strong>浏览器一帧中发送了什么</strong></p><ol><li>处理事件的回调click...事件</li><li>处理计时器的回调</li><li>开始帧</li><li>执行requestAnimationFrame 动画的回调</li><li>计算机页面布局计算 合并到主线程</li><li>绘制</li><li>如果此时还有空闲时间，执行requestIdleCallback（兼容性差，react未选择使用该API）</li></ol><p>每个任务切片不能阻断浏览器的渲染，因此任务切片是宏任务，react 选择使用 MessageChannel 来实现任务调度。同时更具任务切片的优先级，来管理任务切片执行时机。</p><ol><li>立即执行的优先级, 级别最高 [点击事件，输入框]</li><li>用户阻塞级别的优先级, [滚动，拖拽这些]</li><li>正常的优先级 [render 列表 动画 网络请求]</li><li>低优先级 [分析统计]</li><li>最低阶的优先级, 可以被闲置的那种 [console.log]</li></ol><h3 id="事件机制" tabindex="-1">事件机制 <a class="header-anchor" href="#事件机制" aria-label="Permalink to &quot;事件机制&quot;">​</a></h3><p>为了fiber架构中优先级的实现，react会将每个fiber节点上的事件，统一绑定到root节点上，通过冒泡机制来捕获并处理事件。</p><ul><li>用户与页面交互时，浏览器生成一个事件。</li><li>该事件，沿着dom树向上冒泡，直到react的root节点。</li><li>react捕获到事件后，会创建一个 SyntheticEvent 实例，将事件交给相应的事件处理器。</li><li>事件处理完后，SyntheticEvent 不会被销毁，以供下次复用。</li></ul><h3 id="diff" tabindex="-1">Diff <a class="header-anchor" href="#diff" aria-label="Permalink to &quot;Diff&quot;">​</a></h3><p>diff算法对比虚拟dom的前后变化，标记处哪些节点发送了新增、变化、移除。以便实现更轻量的真实dom的更新。新旧树传统地一对一地对比差异的时间复杂度呈指数，因此每个框架都进行了取舍，形成自己独特的diff算法。</p><p>react diff 的实现细节：</p><ul><li>tree层级：不做跨层级比较，只有删除，新建。</li><li>component层级：如何是同类组件，则继续diff子组件，否则删除。</li><li>element层级：当存在key时，顺序遍历新节点，判断元素是否需要移动，删除，新建。（<a href="https://vue3js.cn/interview/React/diff.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">具体算法为快慢指针</a>）</li></ul><h3 id="react中的css解决方案" tabindex="-1">react中的css解决方案 <a class="header-anchor" href="#react中的css解决方案" aria-label="Permalink to &quot;react中的css解决方案&quot;">​</a></h3><ul><li>将css文件作为模块引入: webpack的配置中设置module：true实现</li><li>css in js: 借助三方库 styled-components 实现</li><li>TailWind：</li></ul><h3 id="状态管理" tabindex="-1">状态管理 <a class="header-anchor" href="#状态管理" aria-label="Permalink to &quot;状态管理&quot;">​</a></h3><p>redux</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reducer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">initState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {counter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (action.type) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;INCREMENT&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state, counter: state.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注册</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 派发事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;INCREMENT&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 订阅状态变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscrible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>zustand</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 借助 useSyncExternalStore 实现的轻量状态管理库，核心源码十分简单。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { create } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;zustand&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> useCounterStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ count: state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  decrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ count: state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  reset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h3><p>懒加载，借助 @loadable/component 实现</p><h3 id="杂项" tabindex="-1">杂项 <a class="header-anchor" href="#杂项" aria-label="Permalink to &quot;杂项&quot;">​</a></h3><table tabindex="0"><thead><tr><th>问</th><th>答</th></tr></thead><tbody><tr><td>为什么用className而非class</td><td>js中访问dom节点的class，访问的便是className属性，为了js中的一致性。</td></tr><tr><td>state props 的区别</td><td>state：用于组件内动态数据的创建，值可变。props：用于组件外部向组件传递数据，值不可变。</td></tr><tr><td>state props 的相同点</td><td>两者都是用于保存信息；props 和 state 都能触发渲染更新；</td></tr><tr><td>为什么strictmode回调会触发两次console.log()</td><td></td></tr><tr><td>super() 和 super(props)的区别</td><td>不将props传入super，则在construct内 this.props === undefined</td></tr><tr><td>key的作用</td><td>key是唯一的，用于辅助diff算法。</td></tr><tr><td>事件绑定的最优实践</td><td>类组件中：箭头函数；函数组件中：useCallback</td></tr></tbody></table>`,65)]))}const o=i(e,[["render",t]]);export{c as __pageData,o as default};
