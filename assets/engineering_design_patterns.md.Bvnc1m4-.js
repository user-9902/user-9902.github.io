import{_ as e,c as r,o as t,ag as h}from"./chunks/framework.CPtCmog4.js";const u=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/design_patterns.md","filePath":"engineering/design_patterns.md","lastUpdated":null}'),o={name:"engineering/design_patterns.md"};function i(l,a,n,d,s,c){return t(),r("div",null,a[0]||(a[0]=[h('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h2 id="创建型模式" tabindex="-1">创建型模式 <a class="header-anchor" href="#创建型模式" aria-label="Permalink to &quot;创建型模式&quot;">​</a></h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><h5 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to &quot;工厂模式&quot;">​</a></h5><p>​ 定义一个创建实例的接口，不向用户暴露具体的实例化过程。</p><h6 id="抽象工厂模式" tabindex="-1">抽象工厂模式 <a class="header-anchor" href="#抽象工厂模式" aria-label="Permalink to &quot;抽象工厂模式&quot;">​</a></h6><p>​ 对工厂类的进一步抽象，用于创建工厂类的工厂</p><h6 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h6><p>​ 一个类只有一个实例，暴露一个全局的访问接口，能减少实例化的开销</p><h6 id="建造者模式" tabindex="-1">建造者模式 <a class="header-anchor" href="#建造者模式" aria-label="Permalink to &quot;建造者模式&quot;">​</a></h6><p>​ 构建一个复杂对象时不去关注具体的细节，胶水代码完成复杂对象的创建。主流程串起来，细节分别实现</p><h6 id="原型模式" tabindex="-1">原型模式 <a class="header-anchor" href="#原型模式" aria-label="Permalink to &quot;原型模式&quot;">​</a></h6><p>​ 通过原型实例来代替类型。如js的原型链</p><h2 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to &quot;结构型模式&quot;">​</a></h2><h6 id="装饰器模式" tabindex="-1">装饰器模式 <a class="header-anchor" href="#装饰器模式" aria-label="Permalink to &quot;装饰器模式&quot;">​</a></h6><p>​ 面向切片AOP的思想，不改变原有的类的情况下，插拔式的添加功能</p><h6 id="适配器模式" tabindex="-1">适配器模式 <a class="header-anchor" href="#适配器模式" aria-label="Permalink to &quot;适配器模式&quot;">​</a></h6><p>​ 一个引入的类无法使用现有的接口，不去改造接口，也不是重写引入的类，而是为两者的对接实现一个适配器。</p><h6 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h6><p>​ 不去直接操作对象，而是通过代理来间接访问，如js的Proxy</p><h6 id="桥接模式" tabindex="-1">桥接模式 <a class="header-anchor" href="#桥接模式" aria-label="Permalink to &quot;桥接模式&quot;">​</a></h6><p>​ 一个类存在多个变化维度，保持这些维度的独立。如：书写css样式时定义多个class，一个tag的class由多个拼凑而成，而不是全部书写至一个class定义中。</p><h6 id="组合模式" tabindex="-1">组合模式 <a class="header-anchor" href="#组合模式" aria-label="Permalink to &quot;组合模式&quot;">​</a></h6><p>​ 让对象形成树结构，使其表现出整体与部分的层次结构。如文件系统：根目录下有若干文件和目录，二级目录下还有文件和目录。</p><h6 id="享元模式" tabindex="-1">享元模式 <a class="header-anchor" href="#享元模式" aria-label="Permalink to &quot;享元模式&quot;">​</a></h6><p>​ 尽可能减少实例的创建，去使用现有的实例。如网盘资源共享，保存别人网盘的资源不是拷贝一份磁盘数据，只是保存资源地址。</p><h2 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to &quot;行为型模式&quot;">​</a></h2><h6 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h6><p>​ 遇到分支场景，将各个场景分开来。</p><h6 id="模板方法模式" tabindex="-1">模板方法模式 <a class="header-anchor" href="#模板方法模式" aria-label="Permalink to &quot;模板方法模式&quot;">​</a></h6><p>​ 定义一个抽象类，将具体的实现延迟至子类，但调用由模板决定。如vue就是一个模板抽象类，组件的state，template需要自己去实现，但组件的render、生命周期的执行、由vue这个抽象类决定。</p><h6 id="观察者模式" tabindex="-1">观察者模式 <a class="header-anchor" href="#观察者模式" aria-label="Permalink to &quot;观察者模式&quot;">​</a></h6><p>​ 当对象间存在依赖关系的时候，将对象分为观察者和被观察者，被观察者发生变化的时候，去通知观察者。被观察者需要维护一个list，以便通知观察者。</p><h6 id="订阅发布模式" tabindex="-1">订阅发布模式 <a class="header-anchor" href="#订阅发布模式" aria-label="Permalink to &quot;订阅发布模式&quot;">​</a></h6><p>​ 不同于观察者模式，订阅发布模式多了个订阅中心，用来管理订阅者和发布者，订阅者和发布者不需要知道彼此，结构了两者的关系。</p><h6 id="迭代器模式" tabindex="-1">迭代器模式 <a class="header-anchor" href="#迭代器模式" aria-label="Permalink to &quot;迭代器模式&quot;">​</a></h6><p>​ 提供一种顺序访问聚合对象的方法，无需暴露对象内部的方法。如：链表的迭代器，帮助我们专注链表内部的数据，而无需关注何时调用next</p><h6 id="责任连模式" tabindex="-1">责任连模式 <a class="header-anchor" href="#责任连模式" aria-label="Permalink to &quot;责任连模式&quot;">​</a></h6><p>​ 为多个接收者之前创建引用关系，接受者们都有机会处理请求，当前接受者处理不了则沿着链路传递下去。如：js冒泡、validate</p><h6 id="命令模式" tabindex="-1">命令模式 <a class="header-anchor" href="#命令模式" aria-label="Permalink to &quot;命令模式&quot;">​</a></h6><p>​ 将请求封装成各个命令对象，将客户的请求参数化。如：餐厅点餐，不用告知厨师如何做，直接填写菜单就行。</p><h6 id="备忘录模式" tabindex="-1">备忘录模式 <a class="header-anchor" href="#备忘录模式" aria-label="Permalink to &quot;备忘录模式&quot;">​</a></h6><p>​ 捕获对象在某个时间切片的状态，以便恢复对象。如：游戏存档、数据库事务处理</p><h6 id="状态模式" tabindex="-1">状态模式 <a class="header-anchor" href="#状态模式" aria-label="Permalink to &quot;状态模式&quot;">​</a></h6><p>​ 对象的行为随对象的状态而改变，看起来似乎是类型发生了改变，其实只是状态发生变化。如：数据库链接、在链接前、链接中、链接后会表现出不同行为。</p><h6 id="中介者模式" tabindex="-1">中介者模式 <a class="header-anchor" href="#中介者模式" aria-label="Permalink to &quot;中介者模式&quot;">​</a></h6><p>​ 多个对象间存在复杂的关系，通过一个中介将，网状的关系结构转化为星型的结构。</p><h6 id="解释器模式" tabindex="-1">解释器模式 <a class="header-anchor" href="#解释器模式" aria-label="Permalink to &quot;解释器模式&quot;">​</a></h6><p>​ 编译一种语法、语法。如：RegExp，sql解释器。</p><h3 id="设计" tabindex="-1">设计 <a class="header-anchor" href="#设计" aria-label="Permalink to &quot;设计&quot;">​</a></h3><h5 id="设计一个数据结构-插入-删除-查找-random的时间复杂度都是o-1" tabindex="-1">设计一个数据结构，插入/删除/查找/random的时间复杂度都是O（1） <a class="header-anchor" href="#设计一个数据结构-插入-删除-查找-random的时间复杂度都是o-1" aria-label="Permalink to &quot;设计一个数据结构，插入/删除/查找/random的时间复杂度都是O（1）&quot;">​</a></h5>',51)]))}const q=e(o,[["render",i]]);export{u as __pageData,q as default};
